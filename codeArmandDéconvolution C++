#include <opencv2/opencv.hpp>
#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
using namespace cv;
using namespace std;

double Teinte = 0;double Luminance = 0;double Saturation = 0;double Rouge = 0;double Vert = 0;double Bleu = 0;

void mouseEvent(int evt, int x, int y, int flags, void* param)
{
    Mat* rgb = (Mat*) param;
    if (evt == CV_EVENT_LBUTTONDOWN)
    {
        printf("%d %d BGR: %d, %d, %d\n",
        x, y,
        (int)(*rgb).at<Vec3b>(y, x)[0],
        (int)(*rgb).at<Vec3b>(y, x)[1],
        (int)(*rgb).at<Vec3b>(y, x)[2]);

         Bleu =(int)(*rgb).at<Vec3b>(y, x)[0];
         Vert =(int)(*rgb).at<Vec3b>(y, x)[1];
         Rouge =(int)(*rgb).at<Vec3b>(y, x)[2];

          Mat HSV;
          Mat RGB=(*rgb)(Rect(x,y,1,1));
          cvtColor(RGB, HSV,CV_BGR2HLS);

            Vec3b hsv=HSV.at<Vec3b>(0,0);
            Teinte =2*hsv.val[0];
            Luminance =hsv.val[1];
            Saturation =hsv.val[2];

            printf("%d %d HLS: %d, %d, %d\n",
                   x, y,2*hsv.val[0],hsv.val[1],hsv.val[2]);


    }
}


void RBGclavier ()
{
	int R,G,B,H,S,V;
	cout<< "Entrée les valeurs RBG [0,255] : "<<endl; cin >> R; cin >> G; cin >> B;
	IplImage* RGB=cvCreateImage(cvSize(1, 1), IPL_DEPTH_8U, 3);
	IplImage* HSV=cvCreateImage(cvSize(1, 1), IPL_DEPTH_8U, 3);
	CvScalar rgb;	// représente un scalaire
	rgb.val[0] = B; // valeur du 1er canal
	rgb.val[1] = G; // valeur du 2nd canal
	rgb.val[2] = R; // valeur du 3ème canal
	cvSet2D( RGB, 0, 0, rgb ); // on insère le pixel à l'emplacement voulu
	cvCvtColor(RGB, HSV,CV_BGR2HSV);
	CvScalar hsv1= cvGet2D(HSV,0,0);
	H=hsv1.val[0];
	S=hsv1.val[1];
	V=hsv1.val[2];
	Teinte =hsv1.val[0];
	printf("HSV: %d, %d, %d\n",hsv1.val[0],hsv1.val[1],hsv1.val[2]);

}


int main(int argc, char** argv)
{
 char* imageName = argv[1];
 Mat image, imageC1, imageC2, imageC3, imageC4, imageC5, imageC6;
 image = imread( imageName, 1 );
 IplImage *image2;image2 = cvLoadImage(imageName,1);
 IplImage* hls; hls = cvCloneImage(image2);
 int i,j;
 double patteinte = 0; double teinteMin = 0; double teinteMax = 360;
 double maxM,minM,maxC1,minC1,maxC2,minC2,maxC3,minC3,maxC4,minC4,maxC5,minC5,maxC6,minC6,tampon,valeur,x,y;
 double TRouge=0;double TVert = 0;double TBleu =0; double TJaune =0; double TCyan =0;double TMagenta =0;
 valeur = 0; x = 0;y = 0;
 double pi = 3.14159265358979323846;
 vector<vector<double> > tab_cellule;

 if( argc != 2 || !image.data )
 {
   printf( " No image data \n " );
   return -1;
 }


int choix = 3;
cout<< "Entrez le traitement à effectuer : 0 pour selectionner la couleur sur l'image " <<endl;
cout<< "                                 : 1 pour taper au clavier la couleur RGB " <<endl;
cout<< "                                 : 2 pour taper au clavier la teinte  " <<endl;
cin >> choix;

	if (choix == 0)
	{
		Mat img = imread(imageName, 1);

			    //Create a window
			    namedWindow("My Window", 1);

			    //set the callback function for any mouse event
			    setMouseCallback("My Window", mouseEvent, &img);

			    //show the image
			    imshow("My Window", img);

			    // Wait until user press some key
			    waitKey(0);

	}

	else if (choix == 1)
	{
		RBGclavier();
	}

	else if (choix == 2)
	{
		cout<< "Entrée la valeur teinte du marqueur normalisée [0,255] : "; cin >> Teinte; cout << "" <<endl;
	}

	else
	{
		return -1;
	}


 cvCvtColor(image2, hls, CV_BGR2HLS);

 //cvtColor( image, gray_image, CV_BGR2HSV );
 cvtColor( image, imageC1, CV_BGR2GRAY );
 cvtColor( image, imageC2, CV_BGR2GRAY );
 cvtColor( image, imageC3, CV_BGR2GRAY );
 cvtColor( image, imageC4, CV_BGR2GRAY );
 cvtColor( image, imageC5, CV_BGR2GRAY );
 cvtColor( image, imageC6, CV_BGR2GRAY );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  CvScalar pixel;

  //initialiser Min et Max par les valeurs du pixel (0,0)
  pixel=cvGet2D(hls,0,0);
  Teinte = 2* pixel.val[0];

  TRouge =255*exp(((cos(Teinte*2*pi/360)-0.5)/0.5)-1);
  TVert = 255*exp(((-pow(Teinte,2)+(Teinte*240)-10800)/3600)-1);
  TBleu = 255*exp(((-pow(Teinte,2)+(Teinte*480)-54000)/3600)-1);
  TJaune = 255*exp(((-pow(Teinte,2)+(Teinte*120))/3600)-1);
  TCyan = 255*exp(((-pow(Teinte,2)+(Teinte*360)-28800)/3600)-1);
  TMagenta = 255*exp(((-pow(Teinte,2)+(Teinte*600)-86400)/3600)-1);

  maxC1 = 255-((TRouge*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC1 = maxC1;
  maxC2 = 255-((TVert*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC2 = maxC2;
  maxC3 = 255-((TBleu*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC3 = maxC3;
  maxC4 = 255-((TJaune*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC4 = maxC4;
  maxC5 = 255-((TCyan*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC5 = maxC5;
  maxC6 = 255-((TMagenta*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));minC6 = maxC6;


  //recuperer des min et max dans l'image pour normalisation
  for ( i=0; i<image.rows; i++)
  {
 	 for ( j=0; j<image.cols; j++)
 	 {
 		 pixel=cvGet2D(hls,i,j);
 		 Teinte = 2* pixel.val[0];

 		 TRouge =255*exp(((cos(Teinte*2*pi/360)-0.5)/0.5)-1);
 		 TVert = 255*exp(((-pow(Teinte,2)+(Teinte*240)-10800)/3600)-1);
 		 TBleu = 255*exp(((-pow(Teinte,2)+(Teinte*480)-54000)/3600)-1);
 		 TJaune = 255*exp(((-pow(Teinte,2)+(Teinte*120))/3600)-1);
 		 TCyan = 255*exp(((-pow(Teinte,2)+(Teinte*360)-28800)/3600)-1);
 		 TMagenta = 255*exp(((-pow(Teinte,2)+(Teinte*600)-86400)/3600)-1);

 		 tampon = 255-((TRouge*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC1)
 		 	 {
 		 		 maxC1 = tampon;
 		 	 }
 		 	 if (tampon<minC1)
 		 	 {
 		 		 minC1 = tampon;
 		 	 }
 		 tampon = 255-((TVert*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC2)
 		 	 {
 		 		 maxC2 = tampon;
 		 	 }
 		 	 if (tampon<minC2)
 		 	 {
 		 		 minC2 = tampon;
 		 	 }
 		 tampon = 255-((TBleu*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC3)
 		 	 {
 		 		 maxC3 = tampon;
 		 	 }
 		 	 if(tampon<minC3)
 		 	 {
 		 		 minC3 = tampon;
 		 	 }

 		tampon = 255-((TJaune*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC4)
 		 	 {
 		 		 maxC4 = tampon;
 		 	 }
 		 	 if(tampon<minC4)
 		 	 {
 		 		 minC4 = tampon;
 		 	 }

 	 	tampon = 255-((TCyan*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC5)
 		 	 {
 		 		 maxC5 = tampon;
 		 	 }
 		 	 if(tampon<minC5)
 		 	 {
 		 		 minC5 = tampon;
 		 	 }

 	 	tampon = 255-((TMagenta*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
 		 	 if (tampon>maxC6)
 		 	 {
 		 		 maxC6 = tampon;
 		 	 }
 		 	 if(tampon<minC6)
 		 	 {
 		 		 minC6 = tampon;
 		 	 }

 	 }
  }

 // calcule des valeurs normalisées

  for ( i=0; i<image.rows; i++)
   {
  	 for ( j=0; j<image.cols; j++)
  	 {
  		 pixel=cvGet2D(hls,i,j);

  		Teinte = 2*pixel.val[0];
  		TRouge =255*exp(((cos(Teinte*2*pi/360)-0.5)/0.5)-1);
  		TVert = 255*exp(((-pow(Teinte,2)+(Teinte*240)-10800)/3600)-1);
  		TBleu = 255*exp(((-pow(Teinte,2)+(Teinte*480)-54000)/3600)-1);
  		TJaune = 255*exp(((-pow(Teinte,2)+(Teinte*120))/3600)-1);
  		TCyan = 255*exp(((-pow(Teinte,2)+(Teinte*360)-28800)/3600)-1);
  		TMagenta = 255*exp(((-pow(Teinte,2)+(Teinte*600)-86400)/3600)-1);




  	///////////////////////////////////////////////////////////////////////////////////////////////////




/*
  //deconvovolution suivant la teinte (H)

  		 imageC1.at<uchar>(i,j) = TRouge;
  		 imageC2.at<uchar>(i,j) = TVert;
  		 imageC3.at<uchar>(i,j) = TBleu;
  		 imageC4.at<uchar>(i,j) = TJaune;
  		 imageC5.at<uchar>(i,j) = TCyan;
  		 imageC6.at<uchar>(i,j) = TMagenta;

*/

  		//deconvovolution Globale
/*
  		imageC1.at<uchar>(i,j) = 255-((TRouge*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC2.at<uchar>(i,j) = 255-((TVert*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC3.at<uchar>(i,j) = 255-((TBleu*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC4.at<uchar>(i,j) = 255-((TJaune*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC5.at<uchar>(i,j) = 255-((TCyan*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC6.at<uchar>(i,j) = 255-((TMagenta*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
*/

  		//deconvovolution Globale normalisée

		tampon = 255-((TRouge*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC1.at<uchar>(i,j) = 255*(tampon-minC1)/(maxC1-minC1);
  		tampon = 255-((TVert*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC2.at<uchar>(i,j) = 255*(tampon-minC2)/(maxC2-minC2);
  		tampon = 255-((TBleu*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC3.at<uchar>(i,j) = 255*(tampon-minC3)/(maxC3-minC3);
  		tampon = 255-((TJaune*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC4.at<uchar>(i,j) = 255*(tampon-minC4)/(maxC4-minC4);
  		tampon = 255-((TCyan*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC5.at<uchar>(i,j) = 255*(tampon-minC5)/(maxC5-minC5);
  		tampon = 255-((TMagenta*pixel.val[2]*(255-pixel.val[1]))/(255*(pixel.val[2]+1)));
  		imageC6.at<uchar>(i,j) = 255*(tampon-minC3)/(maxC3-minC3);



  	 }
   }


/////////////////////////////////////////////////////////////////////////////////////////////////////////


/*
 cvSaveImage("resultat.bmp",image2);
 image = imread("resultat.bmp");
 cvtColor( image, gray_image, CV_BGR2GRAY );
 cvtColor( image, image_filtree, CV_BGR2GRAY );
 imwrite( "Gray_Image.bmp", gray_image );

 imshow( "Resultat", image );*/



 cvShowImage("image HLS",hls);
 cvSaveImage("resultat.bmp",hls);

 imshow( "Rouge", imageC1);
 imwrite( "Rouge.bmp", imageC1 );

 imshow( "Vert", imageC2 );
 imwrite( "vert.bmp", imageC2 );

 imshow( "Bleu", imageC3 );
 imwrite( "Bleu.bmp", imageC3);

 imshow( "Jaune", imageC4 );
 imwrite( "Jaune.bmp", imageC4);

 imshow( "Cyan", imageC5 );
 imwrite( "Cyan.bmp", imageC5 );

 imshow( "Magenta", imageC6);
 imwrite( "Magenta.bmp", imageC6);


 waitKey(0);
 return 0;
}
